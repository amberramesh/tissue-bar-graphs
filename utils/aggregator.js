import * as d3 from 'd3'
import fs from 'fs'
import path from 'path'
import { experimentMetaData, ccfAnnotations } from './metadata.js'

const OUTPUT_DIR = 'specimen_data'
const annotationFiles = ['kidney_l1', 'kidney_l2', 'kidney_l3']

if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR);
}

const groupingFns = [d => d['experiment.short'], d => d['annotation.l1'], d => d['annotation.l2'], d => d['annotation.l3']]

const getChildren = ([, value]) => value instanceof Map && Array.from(value);

const getTitle = ({ data }) => data[0] ?? '';

function* dataAccessor({ data }) {
  if (!Array.isArray(data)) return {};
  const [, value] = data;
  if (value instanceof Map) {
    for (const data of value.entries()) {
      yield* dataAccessor({ data });
    }
  } else if (Array.isArray(value)) {
    for (const row of value) {
      yield row;
    }
  }
  return {};
}

function isCellTypeNode(node) {
  const [groupKey, value] = node.data;
  if (!Array.isArray(value)) return false;
  const data = dataAccessor(node).next().value;
  return Object.keys(data)
    // Filter all CT columns
    .filter(k => /CT\/[0-9]+/.test(k))
    // Check if grouping key matches any CT column
    .some(k => groupKey === data[k]);
}

/**
 * Removes entries grouped on empty keys in a nested map recursively,
 * and appends any valid descendants under the lowest common valid ancestor.
 * @param {Map<string, Map | Array>} nestedMap 
 * A nested map, such as one created by D3.group.
 * @see https://github.com/d3/d3-array/blob/v3.0.2/README.md#group
**/
function compressTree(nestedMap) {
  for (const [key, value] of nestedMap.entries()) {
    if (value instanceof Map) {
      compressTree(value);
      if (key === '') {
        let skipDelete = false;
        for (const [nkey, nvalue] of value.entries()) {
          skipDelete |= nkey === key;
          nestedMap.set(nkey, nvalue);
        }
        !skipDelete && nestedMap.delete(key);
      } else if (value.has('') && value.size === 1) {
        nestedMap.set(key, value.get(''));
      }
    }
  }
}

/**
 * Groups flattened data on specified columns into a hierarchical structure.
 * @see https://github.com/d3/d3-array/blob/v3.0.2/README.md#group
 * @param {Array<Array>} csvData Hierarchical CSV data. Follows the format generated by D3.csvParse.
 * @see https://github.com/d3/d3-dsv/blob/v3.0.1/README.md#csvParse
 * @param {RegExp} groupRegex Regular expression for extracting columns to group.
 * @returns {Map} A nested map consisting of key-value pairs.
 */
function groupTreeData(csvData, groupRegex) {
  const groupedData = d3.group(csvData, ...csvData.columns
    .filter(c => groupRegex.test(c))
    // Sort the columns following the AS - CT hierarchy.
    // NOTE: Needs to be modified if other types such as BG are included later.
    .sort((labelA, labelB) => {
      const [typeA, levelA] = labelA.split('/');
      const [typeB, levelB] = labelB.split('/');
      return typeA.localeCompare(typeB) || parseInt(levelA) - parseInt(levelB)
    })
    // Generate grouping function for each column extracted.
    .map(c => d => d[c]));
  compressTree(groupedData);
  return groupedData;
}

/**
 * Computes cell count for cell type hierarchy recursively.
 * @param {Array<Array>} countCsvData Hierarchical CSV data.
 * @param {Map | Array} nestedMap A nested map, or value occurring in a nested map.
 * @returns {number} Total count of cells under a specific type.
 */
function computeCellCount(countCsvData, nestedMap, countMap) {
  let totalCount = 0;
  if (nestedMap instanceof Array) {
    if (!nestedMap[0]) return;
    return parseInt(nestedMap[0][countCsvData.columns.find(c => /^AS\/[0-9]+\/COUNT$/i.test(c))]);
  }
  for (const [key, value] of nestedMap.entries()) {
    countMap.set(key, computeCellCount(countCsvData, value, countMap));
    totalCount += countMap.get(key);
  }
  return totalCount;
}

/**
 * Fetches the cell count hierarchy data for the selected dataset.
 * @param {string} csvDataSrc The path for CSV data source in ASCT+B format.
 * @returns {Promise} State of the asynchronous operation.
 */
function getCellCount(fileName) {
  const fileStream = fs.readFileSync(`raw_data/${fileName}.csv`, {
    encoding: 'utf-8',
    flag: 'r'
  });
  const countMap = new Map();
  const countCsvData = d3.csvParse(fileStream.split('\n').slice(10).join('\n'));
  const groupedData = groupTreeData(countCsvData, /^(AS|CT)\/[0-9]+$/);
  computeCellCount(countCsvData, groupedData, countMap);
  return { groupedData, countMap };
}

const annotationMap = new Map();

for (const fileName of annotationFiles) {
  const file = fs.readFileSync(`raw_data/${fileName}.csv`, {
    encoding: 'utf-8',
    flag: 'r'
  });
  const csvRows = d3.csvParse(file)
  annotationMap.set(fileName, new Map())
  const fileMap = annotationMap.get(fileName)
  for (const row of csvRows) {
    const match = /\[.*\]\(.*(CL_[0-9]+)\)/.exec(row['OBO Ontology ID'])
    fileMap.set(row['Label'], match ? match[1] : '')
  }
}

const csvFile = fs.readFileSync('raw_data/kidney_reference_metadata_forKaty.csv', {
  encoding: 'utf-8',
  flag: 'r'
})

const csvRows = d3.csvParse(csvFile)
const specimenGroups = d3.group(csvRows, ...groupingFns)

const root = d3.hierarchy(specimenGroups, getChildren);

let countMap, cellSet = new Set(), rowCount = 0;
const specimenCTTable = []
console.group('Counts per Dataset')
for (const specimen of root.children) {
  countMap = new Map();
  let countInSpecimen = 0
  const { datasetName, ...metaData } = experimentMetaData[getTitle(specimen)]
  for (const cellType of specimen.leaves()) {
    const levelIdx = cellType.depth - 2
    const annotationLevel = annotationFiles[levelIdx]
    const ontologyId = (() => {
      let level = levelIdx;
      // Search for matches at lower annotation levels
      // when match at the same level is not found
      let match;
      while (level >= 0) {
        match = annotationMap.get(annotationFiles[level]).get(getTitle(cellType))
        if (match) return match;
        level--;
      }
    })();
    const rows = [...dataAccessor(cellType)]
    rowCount += rows.length;
    countMap.set(getTitle(cellType), {
      annotation_level: annotationLevel,
      ontology_id: ontologyId,
      sex: Array.from(new Set(rows.map(row => { if (row['sex'] === 'M') return 'Male'; else if (row['sex'] === 'F') return 'Female'; else return row['sex'] }))).join(';'),
      race: Array.from(new Set(rows.map(row => row['race']))).join(';'),
      count: rows.length,
      percentage: rows.length,
      ...metaData
    })
    countInSpecimen += rows.length
    cellSet.add(getTitle(cellType))
  }
  // Compute percentages
  for (const cellObj of countMap.values()) {
    cellObj['percentage'] = (cellObj['percentage'] * 100 / countInSpecimen).toPrecision(6)
  }
  console.log(`${experimentMetaData[getTitle(specimen)]['datasetName']}: ${countInSpecimen.toLocaleString()}`)
  const summaryText = d3.csvFormat(
    Array.from(countMap)
      .sort(([key1], [key2]) => key1.localeCompare(key2))
      .map(([key, value]) => {
        return {
          'cell_type': key,
          ...value
        }
      })
  );
  fs.writeFileSync(path.join(OUTPUT_DIR, `${experimentMetaData[getTitle(specimen)]['datasetName']}.csv`), summaryText, { encoding: 'utf-8', flag: 'w' })
}
console.groupEnd()

console.group('Observed unique CTs')
for (const ct of Array.from(cellSet).sort()) {
  console.log(ct)
}
console.log('Total cells: ' + rowCount);
console.groupEnd()

// Azimuth CT Grouping and Count
{
  const { groupedData, countMap } = getCellCount('azimuth_kidney');
  const root = d3.hierarchy(['kidney', groupedData], getChildren);
  const csvMap = new Map();
  for (const cellType of root.leaves()) {
    const annotationLevel = annotationFiles[cellType.depth - 1];
    const ctName = getTitle(cellType);
    const data = dataAccessor(cellType).next().value;
    csvMap.set(ctName, {
      annotation_level: annotationLevel,
      ontology_id: annotationMap.get(annotationLevel).get(ctName),
      count: data[Object.keys(data).find(c => /^AS\/[0-9]+\/COUNT$/i.test(c))] // countMap.get(ctName) -- NOTE: This does the bottom-up aggregation, needs clarification for labels repeated over levels
    })
  }

  const summaryText = d3.csvFormat(
    Array.from(csvMap)
      .sort(([key1], [key2]) => key1.localeCompare(key2))
      .map(([key, value]) => {
        return {
          'cell_type': key,
          ...value
        }
      })
  );
  fs.writeFileSync(path.join(OUTPUT_DIR, 'Azimuth.csv'), summaryText, { encoding: 'utf-8', flag: 'w' })
}

// ASCT+B grouping
console.group('Detected CTs for colliding AS:')
{
  const fileStream = fs.readFileSync(`raw_data/Kidney_v1.2_DRAFT - Kidney_v1.2_DRAFT.csv`, {
    encoding: 'utf-8',
    flag: 'r'
  });
  const countCsvData = d3.csvParse(fileStream.split('\n').slice(10).join('\n'));
  const groupedData = groupTreeData(countCsvData, /^(AS|CT)\/[0-9]+$/);
  const root = d3.hierarchy(['kidney', groupedData], getChildren);
  const collidingCells = root.leaves().filter(d => {
    if (!isCellTypeNode(d)) return;
    const data = dataAccessor(d).next().value;
    return Object.values(data).some(v => Object.keys(ccfAnnotations).includes(v))
  })
  console.log(collidingCells.map(d => dataAccessor(d).next().value['CT/1/ID']).filter(v => v));
}
console.groupEnd()
